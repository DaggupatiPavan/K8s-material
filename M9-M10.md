🌐 Module 9 – Service Mesh with Kubernetes (Istio)

🚀 1. Introduction
Modern microservices architectures need advanced networking features:
Service-to-service communication.


Traffic routing (A/B testing, canary releases).


Security (mTLS).


Observability (tracing, monitoring).


A Service Mesh provides:
Transparent proxy between services.


Policy enforcement.


Traffic management & observability without modifying app code.


This module covers:
Introduction to Service Mesh & Istio.


Installing Istio.


Istio Gateway & Ingress.


Traffic control & routing.


Observability using Grafana, Jaeger & Kiali.



🗂️ 2. Istio Basics
📖 Concepts
Envoy Proxy → Sidecar deployed alongside pods.


Istio Control Plane → Manages configuration & policies.


Istio Data Plane → Handles traffic between services.


Gateway → Manages ingress/egress traffic.


VirtualService → Routing rules within mesh.


DestinationRule → Defines policies for specific services.



🧪 3. Hands-on Labs
🔹 Lab 1: Installing Istio
curl -L https://istio.io/downloadIstio | sh -
cd istio-<version>
export PATH=$PWD/bin:$PATH
istioctl install --set profile=demo -y

Verify:
kubectl get pods -n istio-system


🔹 Lab 2: Deploy Sample Application in Istio
kubectl label namespace default istio-injection=enabled
kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml


🔹 Lab 3: Istio Ingress Gateway
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "*"


🔹 Lab 4: Traffic Routing
Route traffic to a specific version (v2)
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v2
      weight: 100

Traffic shifting (50/50)
http:
- route:
  - destination:
      host: reviews
      subset: v1
    weight: 50
  - destination:
      host: reviews
      subset: v2
    weight: 50


🔹 Lab 5: Observability with Grafana, Jaeger & Kiali
Grafana → Metrics dashboards


kubectl -n istio-system port-forward svc/grafana 3000:3000

Jaeger → Distributed tracing


kubectl -n istio-system port-forward svc/jaeger-query 16686:16686

Kiali → Service communication visualization


kubectl -n istio-system port-forward svc/kiali 20001:20001


🚀 4. Advanced Production Strategies
Use mTLS for service-to-service encryption.


Apply Rate limiting & circuit breaking using DestinationRules.


Use Canary releases via VirtualService traffic weights.


Monitor latency & error rates via Grafana & Kiali.


Use Istio Gateways for external traffic management (TLS termination, routing).



🎯 5. Interview & Discussion Questions
What is a Service Mesh, and why is it needed?


Difference between VirtualService and DestinationRule?


How do you perform a canary release using Istio?


What is mTLS, and why use it in Istio?


How does Kiali help in observability?


Explain Istio Gateway vs Kubernetes Ingress.



✅ Summary of Module 9
By completing this module, you now know how to:
Install and configure Istio in Kubernetes.


Expose services using Istio Gateway.


Control traffic routing (canary, A/B testing).


Monitor services using Grafana, Jaeger & Kiali.


Apply service mesh for security, reliability, and observability.


📌 Outcome: You can now design and manage a production-grade service mesh for microservices in Kubernetes.

If you want, I can continue with Module 10 – Helm Charts & CI/CD Deployment in the same professional format next. Do you want me to proceed?



Perfect ✅ Let’s move on to **Module 10 – Helm Charts & CI/CD Deployment in Kubernetes**.

---

# 📦 **Module 10 – Helm Charts & CI/CD Deployment**

---

## 🚀 1. Introduction

Deploying applications directly with raw Kubernetes manifests can be **repetitive, error-prone, and hard to maintain**.

**Helm** is the Kubernetes package manager:

* Packages manifests as **charts**.
* Supports **versioning, templates, and values**.
* Simplifies **application upgrades, rollbacks, and sharing**.

This module covers:

* Helm concepts & architecture.
* Installing Helm.
* Creating, deploying, upgrading, and rolling back applications.
* Using custom values.
* CI/CD integration for automated deployments.

---

## 🗂️ 2. Helm Basics

### 📖 Concepts

* **Chart** → Package of Kubernetes resources.
* **Release** → An instance of a chart deployed in a cluster.
* **Values.yaml** → Configuration for templates.
* **Templates** → Parameterized Kubernetes manifests.

### 🚀 Best Practices

* Keep **values.yaml** clean & environment-specific.
* Use **secrets & ConfigMaps** for sensitive data.
* Version charts for **reproducibility**.
* Store charts in **Helm repositories** (Artifactory, Nexus, ChartMuseum).

---

## 🧪 3. Hands-on Labs

### 🔹 Lab 1: Install Helm

```bash
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
helm version
```

---

### 🔹 Lab 2: Deploy a Chart

```bash
helm repo add bitnami https://charts.bitnami.com/bitnami
helm install my-mysql bitnami/mysql
```

Verify deployment:

```bash
kubectl get pods
helm list
```

---

### 🔹 Lab 3: Using Custom Values

Create `custom-values.yaml`:

```yaml
mysqlRootPassword: myrootpass
mysqlUser: devuser
mysqlPassword: devpass
mysqlDatabase: devdb
```

Deploy using:

```bash
helm install my-mysql -f custom-values.yaml bitnami/mysql
```

---

### 🔹 Lab 4: Upgrade Application

Update image or configuration:

```bash
helm upgrade my-mysql -f custom-values.yaml bitnami/mysql
```

---

### 🔹 Lab 5: Rollback Application

```bash
helm rollback my-mysql 1
```

---

### 🔹 Lab 6: Uninstall Application

```bash
helm uninstall my-mysql
```

---

### 🔹 Lab 7: Creating a New Helm Chart

```bash
helm create myapp
cd myapp
```

* Edit `templates/deployment.yaml` → Add your app container.
* Update `values.yaml` → Configure environment variables, image, replicas.

Deploy:

```bash
helm install myapp ./myapp
```

---

## 🚀 4. Helm in CI/CD

**Integration Tips:**

* Use Helm for **deployment in pipelines** (Jenkins, GitLab, GitHub Actions).
* Separate **values.yaml** per environment (dev, stage, prod).
* Automatically **upgrade and rollback** on pipeline failures.
* Combine **Helm + GitOps** (ArgoCD / Flux) for declarative deployments.

### Example: Jenkins Pipeline Snippet

```groovy
stage('Deploy with Helm') {
  steps {
    sh 'helm upgrade --install myapp ./myapp -f values-${ENV}.yaml'
  }
}
```

---

## 🎯 5. Advanced Production Strategies

* Use **Helm hooks** for pre/post-deployment tasks (migrations, DB init).
* Enable **Chart linting & testing** (`helm lint`, `helm test`).
* Use **Helm repositories** for versioned charts and reproducibility.
* Avoid storing secrets in `values.yaml` → Use **SealedSecrets** or external Vault.

---

## 🎯 6. Interview & Discussion Questions

1. What is the difference between **Helm chart vs Helm release**?
2. How do you manage **environment-specific configurations**?
3. How do you perform **rollbacks using Helm**?
4. What are **Helm hooks**, and why are they useful?
5. How do you integrate **Helm with CI/CD pipelines**?
6. What are the best practices for **storing secrets in Helm charts**?

---

## ✅ Summary of Module 10

By completing this module, you now know how to:

* Use **Helm** to package, deploy, upgrade, and rollback applications.
* Customize deployments using **values.yaml**.
* Build **new Helm charts** for your applications.
* Integrate Helm in **CI/CD pipelines** for automated deployment.
* Apply production best practices for **reliability, security, and maintainability**.

📌 **Outcome**: You can now **manage complex Kubernetes application deployments efficiently and safely using Helm**.
