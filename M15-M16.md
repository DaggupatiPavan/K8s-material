# 🌐 **Module 15 – Ingress Controllers & Advanced Traffic Management**

---

## 🚀 1. Introduction

Kubernetes Ingress Controllers and advanced traffic management help **expose services externally, route traffic, and balance load efficiently**.

This module covers:

* Introduction to Ingress & Ingress Controllers.
* Installing and configuring Nginx Ingress Controller.
* Traffic routing strategies.
* Load balancing & SSL termination.
* Advanced traffic management with Istio or other service meshes.

---

## 🗂️ 2. Kubernetes Ingress

### 📖 Concepts

* **Ingress** → API object to expose HTTP/HTTPS routes to services.
* **Ingress Controller** → Implements Ingress rules (Nginx, Traefik, HAProxy).
* **Benefits:**

  * Centralized routing rules.
  * SSL/TLS termination.
  * Path- or host-based routing.

---

### 🔹 Lab 1: Install Nginx Ingress Controller

```bash
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.1/deploy/static/provider/cloud/deploy.yaml
kubectl get pods -n ingress-nginx
```

---

### 🔹 Lab 2: Expose Service via Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-service
            port:
              number: 80
```

* Verify routing:

```bash
kubectl get ingress
```

---

### 🔹 Lab 3: Load Balancing with Ingress

* Path-based routing:

```yaml
paths:
- path: /frontend
  backend:
    service:
      name: frontend
      port:
        number: 80
- path: /backend
  backend:
    service:
      name: backend
      port:
        number: 80
```

* Host-based routing:

```yaml
rules:
- host: frontend.example.com
- host: backend.example.com
```

---

### 🔹 Lab 4: SSL/TLS Termination

```yaml
tls:
- hosts:
  - myapp.example.com
  secretName: myapp-tls
```

* Create TLS secret:

```bash
kubectl create secret tls myapp-tls --cert=cert.crt --key=cert.key
```

---

## 🗂️ 3. Advanced Traffic Management

* Use **Service Mesh (Istio)** for:

  * Traffic splitting (canary releases).
  * A/B testing.
  * Weighted routing based on percentages.
  * Fault injection for testing resilience.

### 🔹 Lab 5: Traffic Routing with Istio

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: myapp
spec:
  hosts:
  - myapp.example.com
  http:
  - route:
    - destination:
        host: myapp
        subset: v1
      weight: 80
    - destination:
        host: myapp
        subset: v2
      weight: 20
```

* Verify traffic is split 80/20 between versions.

---

### 🔹 Lab 6: Canary Deployment Example

1. Deploy v1 → baseline stable release.
2. Deploy v2 → 10% traffic.
3. Gradually increase traffic using **Istio weights**.
4. Monitor metrics via **Grafana/Kiali**.

---

## 🎯 4. Interview & Discussion Questions

1. What is the difference between **Ingress and Ingress Controller**?
2. How do you configure **path-based vs host-based routing**?
3. How do you terminate **SSL/TLS in Kubernetes**?
4. How would you implement **canary releases** using Ingress or Istio?
5. What are the advantages of using a **service mesh** for traffic management over native Ingress?
6. How do you troubleshoot **Ingress routing issues**?

---

## ✅ Summary of Module 15

By completing this module, you now know how to:

* Deploy **Nginx Ingress Controller** to expose services externally.
* Configure **path-based, host-based routing, and SSL termination**.
* Implement **advanced traffic management** with Istio for canary, A/B testing, and traffic shifting.
* Monitor and control traffic flow in production environments.

📌 **Outcome**: You can now **manage traffic efficiently and securely in Kubernetes clusters**, ensuring high availability, scalability, and smooth rollout of applications.

---

If you want, I can continue with **Module 16 – Putting It All Together: Complete Kubernetes Production-Ready Guide with Labs** to consolidate all concepts into a professional-level end-to-end Kubernetes deployment guide. Do you want me to proceed?

—----------------------------------------------------
Perfect ✅ Let’s move on to **Module 16 – End-to-End Production-Ready Kubernetes Guide**.

---

# 🏗️ **Module 16 – Complete Production-Ready Kubernetes Guide**

---

## 🚀 1. Introduction

This final module consolidates **all previous modules** into an **end-to-end production-grade Kubernetes deployment guide**.

Goals:

* Efficiently deploy, monitor, and manage applications.
* Implement **best practices** for scalability, security, networking, storage, and observability.
* Automate operations using Operators, Helm, and CI/CD pipelines.

---

## 🗂️ 2. Cluster Setup & Configuration

**Best Practices:**

* Use **multi-node clusters** with master & worker separation.
* Apply **RBAC and namespaces** for multi-tenant isolation.
* Enable **resource quotas & limit ranges** per namespace.
* Configure **network policies** for pod-level security.
* Implement **Topology Spread Constraints** and **De-scheduler** for balanced workloads.

**Example:**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: prod-quota
  namespace: production
spec:
  hard:
    pods: "50"
    requests.cpu: "20"
    requests.memory: "50Gi"
```

---

## 🗂️ 3. Application Deployment

**Using Helm Charts:**

* Create charts per microservice.
* Maintain **values.yaml** for different environments.
* Deploy & upgrade apps using:

```bash
helm upgrade --install myapp ./charts/myapp -f values-prod.yaml
```

**Operators for Stateful Apps:**

* Automate database lifecycle (install, backup, scale).
* Example: PostgreSQL or Kafka Operator.

**KubeVirt (if needed):**

* Deploy legacy VM workloads alongside containers.

---

## 🗂️ 4. Networking & Traffic Management

**Ingress & Load Balancing:**

* Use **Nginx Ingress Controller** for external HTTP/S traffic.
* Configure **path/host-based routing** and **TLS termination**.
* For bare-metal clusters → Use **MetalLB** for LoadBalancer services.

**Service Mesh (Istio):**

* Traffic splitting for canary releases and A/B testing.
* Observability through **Kiali & Grafana**.
* Fault injection & traffic shaping for resilience testing.

---

## 🗂️ 5. Scaling & Resource Optimization

**Scaling:**

* Manual scaling: `kubectl scale deployment myapp --replicas=5`
* HPA based on CPU/memory/metrics:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
spec:
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

**Pod Scheduling:**

* NodeSelector, Affinity/Anti-Affinity, Taints & Tolerations.
* TopologySpreadConstraints for high availability.

**Workload Prioritization:**

* QoS Classes → Guaranteed, Burstable, BestEffort.
* PriorityClasses → Ensure critical workloads are not evicted.
* Pod Disruption Budgets → Maintain minimum availability.

---

## 🗂️ 6. Storage Management

* Use **Persistent Volumes (PV) & Persistent Volume Claims (PVC)** for stateful apps.
* Dynamic provisioning with **StorageClass**.
* Ephemeral volumes (emptyDir) for cache or temporary storage.
* HostPath volumes for node-local storage (use cautiously).
* CSI plugins for cloud-native storage solutions.

---

## 🗂️ 7. Observability & Security

**Monitoring:**

* Prometheus for metrics collection.
* Grafana dashboards for visualization.
* Alertmanager for notifications.

**Logging:**

* Fluentd collects logs from pods/nodes.
* Elasticsearch stores & indexes logs.
* Kibana visualizes & searches logs.

**Auditing & Security:**

* Enable Kubernetes audit logs for compliance.
* Falco for runtime security detection.
* NetworkPolicies for zero-trust pod communication.

**Tracing:**

* Use Jaeger for distributed tracing.
* Kiali for service-to-service communication visualization.

---

## 🗂️ 8. CI/CD Integration

* Integrate **Helm and Operators** in pipelines (Jenkins/GitLab/GitHub Actions).
* Pipeline stages:

  1. Build → Containerize → Push to registry
  2. Test → Unit & Integration tests
  3. Deploy → Helm upgrade/install
  4. Monitor → Check metrics/logs, rollback if necessary

**Example Jenkins stage:**

```groovy
stage('Deploy with Helm') {
  steps {
    sh 'helm upgrade --install myapp ./charts/myapp -f values-prod.yaml'
  }
}
```

* Optionally use **GitOps (ArgoCD/Flux)** for declarative deployments.

---

## 🗂️ 9. Best Practices for Production

1. **Namespace & RBAC isolation** per team/environment.
2. **Resource requests & limits** for all pods.
3. **Pod anti-affinity** for spreading workloads across nodes/zones.
4. **Persistent storage** for stateful apps.
5. **Monitor & alert** for CPU, memory, disk, and network.
6. **Logging & tracing** for observability.
7. **Security & auditing** for compliance.
8. **CI/CD pipelines** for automated, reliable deployments.
9. **Service mesh** for advanced traffic management and resilience.

---

## 🎯 10. Interview & Discussion Questions

1. How do you design a **production-grade Kubernetes cluster**?
2. Explain **Helm, Operators, and KubeVirt roles** in deployments.
3. How do you implement **scaling, resource optimization, and high availability**?
4. How do you **secure, monitor, and audit** Kubernetes clusters?
5. How do you implement **advanced traffic management** using Ingress or Istio?
6. How do you integrate **CI/CD pipelines with Helm and Operators**?

---

## ✅ Summary of Module 16

By completing this module, you now know how to:

* Deploy and manage **production-ready Kubernetes clusters**.
* Apply **best practices for networking, storage, scaling, and workload prioritization**.
* Implement **observability, logging, auditing, and security**.
* Integrate **CI/CD pipelines for automated, reliable deployments**.
* Use **service mesh and advanced traffic management** for resilient applications.

📌 **Outcome**: You now have a **comprehensive professional-level understanding** to design, deploy, secure, monitor, and operate **production Kubernetes environments**.
