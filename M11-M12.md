# 🌐 **Module 11 – Advanced Networking & Storage**

---

## 🚀 1. Introduction

Kubernetes networking and storage are **critical for production-grade applications**:

* Proper networking ensures **pod-to-pod and external communication**.
* Persistent storage ensures **data reliability** across pod restarts and node failures.

This module covers:

* CNI (Container Network Interface) & pod networking.
* CSI (Container Storage Interface) & storage plugins.
* Volumes, Persistent Volumes, and Persistent Volume Claims.
* Load balancing & MetalLB for bare-metal.
* Intra-pod & inter-node communication strategies.

---

## 🗂️ 2. Kubernetes Networking (CNI)

### 📖 Concepts

* **CNI (Container Network Interface)** → Plugin for pod networking.
* Pods get **IP addresses** and communicate transparently.
* Popular CNIs: **Calico, Flannel, Weave Net, Cilium**.

### Networking Types

1. **Pod-to-Pod** → Intra-cluster communication.
2. **Pod-to-Service** → Service abstraction for pod sets.
3. **External Access** → NodePort, LoadBalancer, Ingress.
4. **DNS** → CoreDNS resolves services in-cluster.

---

### 🔹 Lab 1: Deploy CNI Plugin (Calico)

```bash
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
```

Verify:

```bash
kubectl get pods -n kube-system
```

---

### 🔹 Lab 2: Apply Network Policies

Allow only frontend pods to communicate with backend pods:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend
  namespace: dev
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
```

---

## 🗂️ 3. Kubernetes Storage (CSI)

### 📖 Concepts

* **CSI (Container Storage Interface)** → Standard for storage plugins.
* **Volume types**:

  * `emptyDir` → ephemeral, pod-lifetime storage.
  * `hostPath` → node-local storage.
  * **PersistentVolume (PV)** → cluster resource.
  * **PersistentVolumeClaim (PVC)** → request for PV.
  * **StorageClass** → dynamic provisioning of PV.
  * **Raw Block** → block-level storage.

---

### 🔹 Lab 3: Using ephemeral Volumes

```yaml
volumes:
- name: temp-storage
  emptyDir: {}
```

---

### 🔹 Lab 4: HostPath Volume

```yaml
volumes:
- name: host-storage
  hostPath:
    path: /mnt/data
    type: Directory
```

---

### 🔹 Lab 5: Persistent Volumes & Claims

**PersistentVolume (PV):**

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-demo
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

**PersistentVolumeClaim (PVC):**

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-demo
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

Mount in pod:

```yaml
volumeMounts:
- mountPath: "/data"
  name: pvc-demo
```

---

### 🔹 Lab 6: StorageClass for Dynamic Provisioning

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
```

---

## ⚡ 4. Load Balancing for Bare-Metal (MetalLB)

* **Problem:** Cloud LoadBalancer not available on bare-metal.
* **Solution:** MetalLB provides **LoadBalancer service support**.

### 🔹 Lab 7: Install MetalLB

```bash
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.10/config/manifests/metallb-native.yaml
```

Configure IP address pool:

```yaml
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: my-ip-pool
  namespace: metallb-system
spec:
  addresses:
  - 192.168.1.240-192.168.1.250
```

---

## 🔍 5. Advanced Communication Strategies

* **Intra-pod communication** → via `emptyDir` or shared volumes.
* **Inter-node communication** → via CNI, Service IP, or LoadBalancer.
* Ensure **DNS resolution** via CoreDNS.
* Use **Network Policies** for **zero-trust pod communication**.

---

## 🎯 6. Interview & Discussion Questions

1. What is the difference between **CNI and CSI**?
2. How does **Pod-to-Pod networking** work in Kubernetes?
3. Explain **PersistentVolume vs PersistentVolumeClaim**.
4. How would you provide **external LoadBalancer** in a bare-metal cluster?
5. What are the best practices for **data persistence and storage security**?
6. How do you restrict pod communication using **NetworkPolicies**?

---

## ✅ Summary of Module 11

By completing this module, you now know how to:

* Configure advanced **pod networking** using CNI & Network Policies.
* Use **volumes, PVs, PVCs, and StorageClasses** for persistent storage.
* Deploy **MetalLB** for bare-metal LoadBalancer support.
* Enable **intra-pod and inter-node communication** with security.
* Apply **production best practices for networking and storage**.

📌 **Outcome**: You can now **design scalable, reliable, and secure Kubernetes networking and storage solutions** for production environments.

---

If you want, I can continue with **Module 12 – Kubernetes Operators & KubeVirt (Custom Operators, OLM, VM on Kubernetes)** in the same professional format next. Do you want me to proceed?

—---------------------------------------------

Perfect ✅ Let’s move on to **Module 12 – Kubernetes Operators & KubeVirt**.

---

# 🤖 **Module 12 – Kubernetes Operators & KubeVirt**

---

## 🚀 1. Introduction

Kubernetes Operators and KubeVirt extend Kubernetes beyond container orchestration:

* **Operators** → Automate the management of complex applications using Kubernetes APIs.
* **KubeVirt** → Runs Virtual Machines (VMs) alongside containers, enabling hybrid workloads.

This module covers:

* Introduction to Operators & Operator Ecosystem.
* Building, deploying, and managing custom operators.
* Operator Lifecycle Manager (OLM).
* KubeVirt architecture and installation.
* Deploying and managing VMs on Kubernetes.

---

## 🗂️ 2. Kubernetes Operators

### 📖 Concepts

* **Operator** = Custom controller that extends Kubernetes API.
* Automates tasks like: install, configure, update, backup, failover.
* **Operator SDK** → Framework to build operators (Go, Ansible, Helm).
* **OLM (Operator Lifecycle Manager)** → Manages operators in clusters.
* **OperatorHub** → Registry of community operators.

---

### 🔹 Lab 1: Deploy a Prebuilt Operator

Example: PostgreSQL Operator

```bash
kubectl apply -f https://operatorhub.io/install/postgresql.yaml
kubectl get csv -n operators
```

---

### 🔹 Lab 2: Build a Custom Operator (Helm-based)

```bash
operator-sdk init --domain=example.com --plugins=helm
operator-sdk create api --group=app --version=v1 --kind=MyApp
```

* Define **Helm chart** for your app.
* Deploy the operator:

```bash
make install
make run
```

---

### 🔹 Lab 3: Using Operator Lifecycle Manager (OLM)

* Install OLM:

```bash
kubectl apply -f https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.27.3/install.yaml
```

* Deploy operator via **OperatorHub**.
* Verify:

```bash
kubectl get operators -n olm
kubectl get csv -n olm
```

---

### 🔹 Lab 4: Deploy Custom Resource via Operator

```yaml
apiVersion: app.example.com/v1
kind: MyApp
metadata:
  name: myapp-instance
spec:
  size: 3
```

Operator automatically manages:

* Deployment
* Scaling
* Updates & Rollbacks

---

## 🗂️ 3. KubeVirt – Running VMs on Kubernetes

### 📖 Concepts

* **KubeVirt** = Run VMs as Kubernetes resources (`VirtualMachine`, `VirtualMachineInstance`).
* Bridges container & VM workloads on the same cluster.
* **Components**:

  * **virt-api** → API server for VM resources.
  * **virt-controller** → VM lifecycle management.
  * **virt-launcher** → Pod that runs the VM.

---

### 🔹 Lab 5: Install KubeVirt

```bash
kubectl create namespace kubevirt
kubectl apply -f https://github.com/kubevirt/kubevirt/releases/download/v0.82.0/kubevirt-operator.yaml
kubectl apply -f https://github.com/kubevirt/kubevirt/releases/download/v0.82.0/kubevirt-cr.yaml
kubectl get pods -n kubevirt
```

---

### 🔹 Lab 6: Deploy a VM on Kubernetes

```yaml
apiVersion: kubevirt.io/v1
kind: VirtualMachine
metadata:
  name: myvm
spec:
  running: true
  template:
    spec:
      domain:
        devices:
          disks:
          - name: containerdisk
            disk:
              bus: virtio
        resources:
          requests:
            memory: 1Gi
      volumes:
      - name: containerdisk
        containerDisk:
          image: kubevirt/cirros-container-disk-demo
```

Verify VM:

```bash
kubectl get vms
kubectl get vmi
```

Access VM console:

```bash
virtctl console myvm
```

---

## 🚀 4. Advanced Production Strategies

* **Operators**

  * Automate repetitive tasks for **stateful apps** (databases, message queues).
  * Ensure **self-healing** & **consistent deployments**.
* **KubeVirt**

  * Enables **hybrid workloads** in Kubernetes.
  * Combine **containerized apps & legacy VM workloads** in same cluster.
* Apply **RBAC and NetworkPolicies** to secure operators & VMs.
* Use **ResourceQuota & LimitRanges** to control VM consumption.

---

## 🎯 5. Interview & Discussion Questions

1. What is a **Kubernetes Operator**, and why use it?
2. Explain the **Operator SDK & OLM**.
3. How do Operators help with **stateful workloads**?
4. What is **KubeVirt**, and how does it integrate with Kubernetes?
5. How do you access a **VM running in KubeVirt**?
6. What are **production best practices for Operators and KubeVirt**?

---

## ✅ Summary of Module 12

By completing this module, you now know how to:

* Understand and deploy **Kubernetes Operators**.
* Build and manage **custom operators** using Operator SDK.
* Use **OLM** for operator lifecycle management.
* Install **KubeVirt** and deploy VMs on Kubernetes.
* Integrate **VM and container workloads** on the same cluster.

📌 **Outcome**: You can now **automate complex workloads and run hybrid container-VM environments** in Kubernetes clusters for production scenarios.
