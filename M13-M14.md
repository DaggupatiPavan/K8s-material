# ⚙️ **Module 13 – Advanced Cluster Management, Scaling & Resource Optimization**

---

## 🚀 1. Introduction

Managing a production Kubernetes cluster requires **efficient resource usage, workload prioritization, and high availability**.

This module covers:

* Resource prioritization & Quality of Service (QoS).
* Pod scheduling strategies (NodeSelector, Affinity/Anti-Affinity, Taints/Tolerations).
* Scaling workloads (manual & auto-scaling).
* Pod Disruption Budgets (PDB).
* Topology spread and cluster de-scheduler.
* Namespaces, ResourceQuotas, and LimitRanges.

---

## 🗂️ 2. Resource Prioritization & QoS

### 📖 Concepts

* **QoS Classes:**

  * **Guaranteed** → CPU & memory requests = limits → high priority.
  * **Burstable** → CPU/memory requests < limits → medium priority.
  * **BestEffort** → No requests/limits → lowest priority.

### 🔹 Lab 1: Changing QoS for Pods

```yaml
resources:
  requests:
    memory: "512Mi"
    cpu: "500m"
  limits:
    memory: "512Mi"
    cpu: "500m"
```

Check QoS:

```bash
kubectl get pod mypod -o jsonpath='{.status.qosClass}'
```

---

## 🗂️ 3. Priority Classes

* Control **pod eviction order** under resource pressure.
* Example:

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "High priority pods"
```

Apply to pod:

```yaml
priorityClassName: high-priority
```

---

## 🗂️ 4. Pod Scheduling Strategies

### 🔹 NodeSelector

* Schedule pods to specific nodes.

```yaml
nodeSelector:
  disktype: ssd
```

### 🔹 Affinity / Anti-Affinity

* Control pod placement based on labels.

```yaml
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app
          operator: In
          values:
          - backend
      topologyKey: "kubernetes.io/hostname"
```

### 🔹 Taints & Tolerations

* Taint nodes to restrict pod scheduling.

```yaml
kubectl taint nodes node1 key=value:NoSchedule
```

Pod toleration:

```yaml
tolerations:
- key: "key"
  operator: "Equal"
  value: "value"
  effect: "NoSchedule"
```

---

## 🗂️ 5. Pod Disruption Budgets (PDB)

* Ensures minimum **availability during voluntary disruptions**.

```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: backend-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: backend
```

---

## 🗂️ 6. Scaling Resources

### 🔹 Manual Scaling

```bash
kubectl scale deployment myapp --replicas=5
```

### 🔹 Horizontal Pod Autoscaler (HPA)

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

---

## 🗂️ 7. Topology Spread & De-scheduler

* **Topology Spread Constraints** → Distribute pods across zones/nodes.

```yaml
topologySpreadConstraints:
- maxSkew: 1
  topologyKey: topology.kubernetes.io/zone
  whenUnsatisfiable: DoNotSchedule
  labelSelector:
    matchLabels:
      app: myapp
```

* **De-scheduler** → Dynamically rebalance pods to improve resource usage.
* Policies: **Evict low-priority pods, balance nodes, enforce affinity/anti-affinity**.

---

## 🗂️ 8. Namespaces & Resource Quotas

### 📖 Concepts

* **Namespaces** → Logical separation of cluster resources.
* **ResourceQuotas** → Limit CPU, memory, pods per namespace.
* **LimitRanges** → Set min/max resource per pod/container.

### 🔹 Lab 1: Resource Quota on Namespace

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "4"
    requests.memory: 8Gi
```

### 🔹 Lab 2: Limit Ranges

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: limits
  namespace: dev
spec:
  limits:
  - default:
      cpu: "500m"
      memory: "512Mi"
    defaultRequest:
      cpu: "200m"
      memory: "256Mi"
    type: Container
```

---

## 🎯 9. Interview & Discussion Questions

1. What are the differences between **Guaranteed, Burstable, and BestEffort QoS**?
2. How do **PriorityClasses** affect pod eviction?
3. How do **NodeSelector, Affinity, Taints, and Tolerations** work together?
4. How would you **scale applications** manually and automatically?
5. Explain **Pod Disruption Budgets** and use cases.
6. How do **ResourceQuotas and LimitRanges** help in multi-tenant clusters?
7. What is **Topology Spread**, and why is it important?
8. How does **De-scheduler** optimize cluster resources?

---

## ✅ Summary of Module 13

By completing this module, you now know how to:

* Prioritize critical workloads using **QoS and PriorityClasses**.
* Optimize pod scheduling using **NodeSelector, Affinity/Anti-Affinity, Taints/Tolerations**.
* Scale workloads using **manual and auto-scaling strategies**.
* Ensure **high availability** using Pod Disruption Budgets.
* Manage **namespaces, resource quotas, and limit ranges**.
* Balance workloads across the cluster with **Topology Spread & De-scheduler**.

📌 **Outcome**: You can now **efficiently manage, optimize, and scale production Kubernetes clusters** for reliability and performance.

---

If you want, I can continue with **Module 14 – Logging, Monitoring, Auditing & Observability with Prometheus, Grafana, Fluentd, Falco, and EFK Stack** next in the same professional format. Do you want me to proceed?

—-------------------------------------------

Perfect ✅ Let’s move on to **Module 14 – Logging, Monitoring, Auditing & Observability in Kubernetes**.

---

# 📊 **Module 14 – Logging, Monitoring, Auditing & Observability**

---

## 🚀 1. Introduction

Observability in Kubernetes is critical for **proactive monitoring, troubleshooting, and security**.

Key components:

* **Metrics** → CPU, memory, network usage.
* **Logs** → Application & system events.
* **Tracing** → Request flow across microservices.
* **Security monitoring** → Detect abnormal behavior.

This module covers:

* Prometheus & Grafana for metrics.
* Logging solutions (Fluentd, EFK/ELK).
* Auditing & security monitoring (Falco).
* Visualization & distributed tracing.

---

## 🗂️ 2. Monitoring with Prometheus & Grafana

### 📖 Concepts

* **Prometheus** → Time-series metrics collection.
* **Grafana** → Visualize metrics dashboards.
* **Alertmanager** → Sends alerts on metric thresholds.

---

### 🔹 Lab 1: Install Prometheus & Grafana

```bash
kubectl create namespace monitoring
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm install prometheus prometheus-community/kube-prometheus-stack -n monitoring
```

Verify:

```bash
kubectl get pods -n monitoring
```

---

### 🔹 Lab 2: Visualize Metrics in Grafana

* Port-forward Grafana:

```bash
kubectl port-forward svc/prometheus-grafana 3000:80 -n monitoring
```

* Default credentials: admin/admin
* Import dashboards: Kubernetes cluster metrics, Pod CPU/Memory, Node metrics

---

### 🔹 Lab 3: Configure Alerts

* Create PrometheusRule for high CPU usage:

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: high-cpu
  namespace: monitoring
spec:
  groups:
  - name: cpu-alert
    rules:
    - alert: HighCPUUsage
      expr: sum(rate(container_cpu_usage_seconds_total[2m])) by (pod) > 0.8
      for: 2m
      labels:
        severity: warning
      annotations:
        summary: "High CPU usage detected"
```

---

## 🗂️ 3. Logging with EFK (Elasticsearch, Fluentd, Kibana)

### 📖 Concepts

* **Fluentd** → Collects logs from pods & nodes.
* **Elasticsearch** → Centralized log storage & indexing.
* **Kibana** → Visualize and search logs.

### 🔹 Lab 4: Deploy EFK Stack

```bash
kubectl apply -f https://raw.githubusercontent.com/elastic/cloud-on-k8s/master/config/samples/efk-stack.yaml
```

* Verify logs are indexed and searchable in Kibana.

---

## 🗂️ 4. Security Monitoring with Falco

### 📖 Concepts

* Falco detects **abnormal container behavior** using syscall rules.
* Can alert on **unauthorized access, process execution, file changes**.

### 🔹 Lab 5: Install Falco

```bash
kubectl apply -f https://raw.githubusercontent.com/falcosecurity/falco/master/kubernetes/falco-daemonset.yaml
kubectl get pods -n falco
```

* Create custom rules for security policies.

---

## 🗂️ 5. Auditing in Kubernetes

* Enable **Audit Logs** for cluster events (API access, changes, failed requests).
* Configure `audit-policy.yaml`:

```yaml
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Metadata
  verbs: ["create", "update", "delete"]
  resources:
  - group: ""
    resources: ["pods", "services"]
```

* Enable auditing in kube-apiserver with:

```bash
--audit-policy-file=/etc/kubernetes/audit-policy.yaml
--audit-log-path=/var/log/k8s-audit/audit.log
```

---

## 🗂️ 6. Distributed Tracing

* **Jaeger** → Traces requests across microservices.
* **Kiali** → Visualize service communication & mesh metrics.

### 🔹 Lab 6: Install Jaeger & Kiali

```bash
kubectl apply -f https://github.com/istio/istio/releases/download/1.19.1/jaeger.yaml
kubectl apply -f https://github.com/istio/istio/releases/download/1.19.1/kiali.yaml
```

* Access Jaeger UI:

```bash
kubectl port-forward svc/jaeger-query 16686:16686
```

* Access Kiali UI:

```bash
kubectl port-forward svc/kiali 20001:20001
```

---

## 🎯 7. Interview & Discussion Questions

1. Explain **Prometheus and Grafana** workflow for monitoring.
2. How does **EFK stack** centralize logs in Kubernetes?
3. What is **Falco**, and how is it used for security?
4. How do you enable **Kubernetes auditing**, and what events are important?
5. What is **distributed tracing**, and how do **Jaeger and Kiali** help?
6. How do you configure **alerts and notifications** for production clusters?

---

## ✅ Summary of Module 14

By completing this module, you now know how to:

* Collect, store, and visualize metrics using **Prometheus & Grafana**.
* Centralize and search logs with **Fluentd + Elasticsearch + Kibana (EFK)**.
* Implement **security monitoring** using Falco.
* Enable **Kubernetes auditing** for compliance and troubleshooting.
* Perform **distributed tracing** using Jaeger and visualize service communication with Kiali.

📌 **Outcome**: You can now **monitor, audit, and secure Kubernetes clusters and applications effectively**, ensuring production reliability and observability.

