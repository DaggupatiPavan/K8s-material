Perfect ✅ Let’s move into **Module 7 – Logging & Observability in Kubernetes**.

---

# 📊 **Module 7 – Logging & Observability**

---

## 🚀 1. Introduction

In production, running applications without **observability** is like flying an airplane blindfolded.

🔑 Observability = **Logs + Metrics + Traces**

* **Logs** → What happened? (event details)
* **Metrics** → How is the system performing? (CPU, memory, latency, error rate)
* **Traces** → Why is it slow? (request flow across services)

This module covers:

* Kubernetes logging approaches.
* Log aggregation solutions.
* Metrics collection & monitoring with Prometheus + Grafana.
* Tracing with Jaeger & Kiali.
* Auditing & alerting strategies.

---

## 🗂️ 2. Logging in Kubernetes

### 📖 Concepts

1. **Container logs** → `kubectl logs <pod>` (basic debugging).
2. **Sidecar logging** → Ship logs from app container to collector.
3. **DaemonSet logging** → Node-level log collectors (e.g., Fluentd, Fluent Bit, Vector).
4. **Centralized logging** → ELK Stack (Elasticsearch, Logstash, Kibana) or EFK (Fluentd/Fluent Bit).

### 🚀 Best Practices

* Always **centralize logs** (don’t depend only on `kubectl logs`).
* Use **structured logs (JSON)** for parsing.
* Rotate logs to prevent disk issues (`logrotate`).

---

## 🧪 3. Hands-on Labs

### 🔹 Lab 1: Access Container Logs

```bash
kubectl logs mypod -c mycontainer
```

---

### 🔹 Lab 2: Deploy Fluent Bit (lightweight log forwarder)

```bash
kubectl apply -f https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-daemonset.yaml
```

👉 Collects logs and ships them to Elasticsearch or CloudWatch.

---

### 🔹 Lab 3: Centralized EFK Stack

* **Elasticsearch** → stores logs.
* **Fluentd/Fluent Bit** → collects & ships logs.
* **Kibana** → visualize logs.

Deploy using Helm:

```bash
helm repo add elastic https://helm.elastic.co
helm install efk elastic/elastic-stack
```

---

## 📈 4. Metrics & Monitoring

### 📖 Concepts

* **Prometheus** → Metrics collection (scrapes targets).
* **Grafana** → Dashboard & visualization.
* **Kube-State-Metrics** → Cluster object metrics.
* **Node Exporter** → Node-level metrics.
* **Alertmanager** → Send alerts (Slack, email, PagerDuty).

---

### 🔹 Lab 4: Install Prometheus + Grafana

```bash
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm install kube-prom prometheus-community/kube-prometheus-stack
```

👉 Access Grafana:

```bash
kubectl port-forward svc/kube-prom-grafana 3000:80
```

Default login: `admin / prom-operator`

---

### 🔹 Lab 5: Create Custom Dashboard in Grafana

* CPU / Memory Usage per Pod.
* HTTP Request Latency.
* Error Rate (5xx).
* Disk Usage.

---

### 🔹 Lab 6: Configure Alerts

Prometheus `alerting-rules.yaml`:

```yaml
groups:
- name: node.rules
  rules:
  - alert: HighNodeCPU
    expr: node_cpu_seconds_total > 0.9
    for: 2m
    labels:
      severity: warning
    annotations:
      description: "Node CPU usage > 90%"
```

---

## 🔍 5. Distributed Tracing

### 📖 Concepts

* **Jaeger** → Distributed tracing system.
* **Kiali** → Service Mesh observability (if using Istio).
* Helps trace request flow across microservices.

---

### 🔹 Lab 7: Install Jaeger

```bash
kubectl create namespace observability
kubectl apply -n observability -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.45.0/jaeger-operator.yaml
```

Access Jaeger UI:

```bash
kubectl port-forward svc/jaeger-query 16686:16686 -n observability
```

---

## 🔐 6. Auditing in Kubernetes

* **Audit Logs** capture requests to Kubernetes API server.
* Configure audit policy:

```yaml
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Metadata
  verbs: ["create", "delete"]
  resources:
  - group: ""
    resources: ["pods", "deployments"]
```

👉 Helps in **security & compliance monitoring**.

---

## 🚀 7. Advanced Production Strategies

* Ship logs to **cloud-native services** (CloudWatch, GCP Logging, Azure Monitor).
* Use **Grafana Loki** (lightweight log aggregation).
* Setup **alerting integration with Slack/Teams**.
* Apply **RBAC** on who can view sensitive logs.
* Use **OpenTelemetry** for unified logs, metrics, and traces.

---

## 🎯 8. Interview & Discussion Questions

1. What’s the difference between **logs, metrics, and traces**?
2. How do you set up **centralized logging** in Kubernetes?
3. Why use **Fluentd/Fluent Bit** instead of direct logging?
4. How does **Prometheus scrape metrics** from pods?
5. How do you monitor **microservices latency & dependencies**?
6. Difference between **Grafana Loki** and **EFK stack**?

---

## ✅ Summary of Module 7

By completing this module, you now know how to:

* Collect, store, and query logs (EFK / Fluent Bit).
* Monitor clusters with Prometheus & Grafana.
* Trace distributed requests with Jaeger.
* Configure Kubernetes audit logging.
* Build a **complete observability stack**.

📌 **Outcome**: You can now **design end-to-end observability for Kubernetes clusters** to monitor health, detect issues early, and debug faster.

---

👉 Do you want me to continue with **Module 8 – Kubernetes Security & RBAC (Secrets, PodSecurityPolicies, NetworkPolicies, Runtime Security, OPA/Gatekeeper, Security Best Practices)** in the same professional format?


—-----------------------------------------------

Perfect ✅ Let’s move on to **Module 8 – Kubernetes Security & RBAC**.

---

# 🔒 **Module 8 – Kubernetes Security & RBAC**

---

## 🚀 1. Introduction

Security is **critical in production Kubernetes clusters** because:

* Multiple teams may share a cluster.
* Workloads may contain sensitive data (DB passwords, API keys).
* Misconfigurations can lead to **data breaches, privilege escalation, or cluster compromise**.

This module covers:

* Authentication & Authorization.
* RBAC (Role-Based Access Control).
* Secrets Management.
* Pod Security & SecurityContext.
* Network Policies & Runtime Security.
* OPA/Gatekeeper for policy enforcement.
* Security Best Practices for production.

---

## 🗂️ 2. Authentication & Authorization

### 📖 Concepts

* **Authentication** → Who are you? (Users, ServiceAccounts)
* **Authorization** → What can you do? (RBAC, ABAC, Webhook)
* Kubernetes supports **X.509 certificates, Tokens, OpenID Connect, and ServiceAccounts**.

### 🚀 Best Practices

* Use **ServiceAccounts** for pods.
* Avoid using `default` SA with cluster-admin privileges.
* Integrate **OIDC or LDAP** for user authentication.

---

## 🧪 3. RBAC (Role-Based Access Control)

### 📖 Concepts

* **Role** → namespace-scoped permissions.
* **ClusterRole** → cluster-wide permissions.
* **RoleBinding** → binds Role to user/group/SA.
* **ClusterRoleBinding** → binds ClusterRole cluster-wide.

### 🔹 Lab 1: Create Role & RoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pod-reader
  namespace: dev
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: dev
subjects:
- kind: User
  name: alice
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

---

### 🔹 Lab 2: ClusterRole & ClusterRoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-admin-read
rules:
- apiGroups: [""]
  resources: ["nodes", "pods"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-all
subjects:
- kind: User
  name: bob
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: cluster-admin-read
  apiGroup: rbac.authorization.k8s.io
```

---

## 🗝️ 4. Secrets Management

### 📖 Concepts

* Store **sensitive info** (passwords, keys, certificates).
* Avoid **hardcoding secrets in YAML or code**.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
stringData:
  username: admin
  password: p@ssw0rd
```

Mount in Pod:

```yaml
volumeMounts:
- name: secret-volume
  mountPath: /etc/secret
volumes:
- name: secret-volume
  secret:
    secretName: db-secret
```

### 🚀 Best Practices

* Use **KMS / Vault** for encrypting secrets.
* Enable **encryption at rest** for Kubernetes Secrets.
* Avoid logging secrets accidentally.

---

## 🛡️ 5. Pod Security & SecurityContext

### 📖 Concepts

* Control **capabilities, user IDs, filesystem access**.
* SecurityContext example:

```yaml
securityContext:
  runAsUser: 1000
  runAsGroup: 3000
  fsGroup: 2000
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
```

* **PodSecurityPolicies (PSP)** – Deprecated in K8s 1.25+, replaced by **Pod Security Admission**.

### 🔹 Lab 3: Apply Pod Security Admission

```bash
kubectl label namespace dev pod-security.kubernetes.io/enforce=restricted
```

---

## 🌐 6. Network Policies (Advanced Security)

* Restrict which pods can communicate with each other.
* Example: Only frontend can access backend pods:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
  namespace: dev
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
```

---

## ⚡ 7. Runtime Security

* Use **Falco** or **Kube-bench** for security monitoring.
* Detect **abnormal system calls, privilege escalation, and network anomalies**.
* Integrate with **Prometheus/Grafana** for alerts.

### 🔹 Lab 4: Install Falco

```bash
kubectl apply -f https://raw.githubusercontent.com/falcosecurity/falco/master/kubernetes/falco-daemonset.yaml
```

---

## 🏛️ 8. Policy Enforcement with OPA/Gatekeeper

* **Open Policy Agent (OPA)** + Gatekeeper = enforce custom security policies.
* Example: Prevent pods running as root.

```yaml
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sdenyroot
spec:
  crd:
    spec:
      names:
        kind: K8sDenyRoot
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sdenyroot
        violation[{"msg": msg}] {
          input.review.object.spec.containers[_].securityContext.runAsUser == 0
          msg := "Running as root is not allowed"
        }
```

---

## 🚀 9. Production Security Best Practices

1. **Enable RBAC** cluster-wide.
2. **Use namespaces** for isolation.
3. **Encrypt Secrets** & use Vault/KMS.
4. **Use PodSecurity Admission** (restricted/privileged policies).
5. **Implement Network Policies** for zero-trust networking.
6. **Run pods as non-root** with least privileges.
7. Monitor **runtime security** using Falco or Kube-bench.
8. Regularly scan images using **Trivy / Clair**.

---

## 🎯 10. Interview & Discussion Questions

1. What’s the difference between **Role vs ClusterRole**?
2. How do **Taints & Tolerations** relate to security?
3. How do you manage **sensitive credentials** in Kubernetes?
4. What is **PodSecurityPolicy / Pod Security Admission**?
5. How would you implement **network isolation between teams**?
6. Explain **Falco & OPA/Gatekeeper** in cluster security.

---

## ✅ Summary of Module 8

By completing this module, you now know how to:

* Secure access with **RBAC**.
* Protect workloads with **Secrets, SecurityContext, PodSecurity**.
* Enforce **network isolation** with Network Policies.
* Monitor runtime security with **Falco**.
* Apply **policy enforcement** with OPA/Gatekeeper.

📌 **Outcome**: You can now design **production-grade, secure Kubernetes clusters** adhering to best practices and compliance standards.

