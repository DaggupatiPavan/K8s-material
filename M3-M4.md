
# 🌐 **Module 3 – Networking & Traffic Management in Kubernetes**

---

## 🚀 1. Introduction

Networking is the backbone of Kubernetes. It enables:

* Communication **inside the cluster** (Pod ↔ Pod).
* Communication **outside the cluster** (Ingress, LoadBalancer, Services).
* Traffic security, routing, and observability.

In production, **misconfigured networking** can cause:

* Pod-to-pod communication failures.
* Load balancing issues.
* Security vulnerabilities (open NodePorts, unencrypted traffic).

This module covers:

* Cluster networking fundamentals.
* Kubernetes Services (ClusterIP, NodePort, LoadBalancer, ExternalName).
* Ingress & Ingress Controllers.
* Network Policies for security.
* Service Mesh (Istio/Linkerd) overview.

---

## 🗂️ 2. Kubernetes Networking Basics

### 📖 Concepts

* Each **Pod gets its own IP** (via CNI plugin like Flannel, Calico, Cilium).
* Pods on different nodes can communicate without NAT (K8s requirement).
* Services provide **stable DNS names** for pods.

### 🚀 Best Practices

* Use **CNI plugins** like Calico for enterprise networking & policies.
* Avoid direct Pod-to-Pod communication → always use Services.

---

## 🔗 3. Kubernetes Services

### 📖 Types of Services

1. **ClusterIP (default)**

   * Internal-only access.
   * Used for **internal microservice communication**.

2. **NodePort**

   * Opens a port on every node.
   * Not recommended for production (security risk).

3. **LoadBalancer**

   * Uses cloud provider LB (AWS ELB, Azure LB, GCP LB).
   * Standard for exposing apps externally.

4. **ExternalName**

   * Maps a service to an external DNS.

### 🧪 Labs

**ClusterIP Example**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend
spec:
  type: ClusterIP
  selector:
    app: backend
  ports:
  - port: 80
    targetPort: 8080
```

**NodePort Example**

```yaml
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30007
```

**LoadBalancer Example** (cloud only)

```yaml
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
```

**ExternalName Example**

```yaml
spec:
  type: ExternalName
  externalName: api.example.com
```

### 🚀 Best Practices

* Prefer **ClusterIP + Ingress** over NodePort.
* Use **LoadBalancer** only when you can’t use Ingress.

---

## 🌍 4. Ingress & Ingress Controllers

### 📖 Concepts

* **Ingress**: Exposes HTTP/HTTPS routes from outside to Services.
* Needs an **Ingress Controller** (NGINX, Traefik, HAProxy, AWS ALB Ingress).

### 🧪 Lab

**Basic Ingress**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ingress
spec:
  rules:
  - host: web.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

👉 Deploy NGINX Ingress Controller:

```bash
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
```

### 🚀 Best Practices

* Use **TLS/HTTPS** for Ingress (cert-manager + Let’s Encrypt).
* Use **path-based** and **host-based** routing.
* For AWS → use **AWS ALB Ingress Controller**.

---

## 🔒 5. Network Policies (Security)

### 📖 Concepts

* By default, **all pods can talk to each other**.
* Network Policies restrict ingress/egress.
* Example: only allow frontend → backend traffic.

### 🧪 Lab

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
```

### 🚀 Best Practices

* Default deny all traffic, then allow explicitly.
* Apply **namespace-level isolation**.
* Use **Calico or Cilium** for advanced policy enforcement.

---

## 🔁 6. Service Mesh (Istio, Linkerd, Consul)

### 📖 Concepts

* Service Mesh = layer on top of K8s networking.
* Features:

  * **mTLS** (security).
  * **Traffic shifting** (canary, blue/green).
  * **Retries, circuit breaking**.
  * **Observability (tracing, metrics, logs)**.

### 🚀 Best Practices

* Use Istio if you need **advanced traffic control**.
* Use Linkerd if you need **lightweight + simpler setup**.
* Don’t start with a Service Mesh unless absolutely needed → complexity.

---

## 🎯 7. Interview & Discussion Questions

1. Difference between **ClusterIP, NodePort, and LoadBalancer**?
2. Why do we need an **Ingress Controller** instead of NodePort?
3. How do you enforce **network security between namespaces**?
4. What is the role of **CNI plugins** in Kubernetes?
5. Can you explain **how Service Mesh handles retries** compared to native K8s?

---

## ✅ Summary of Module 3

By completing this module, you should now be able to:

* Use **Services** to expose workloads.
* Configure **Ingress with TLS** for external routing.
* Apply **Network Policies** for zero-trust security.
* Understand when to use a **Service Mesh**.

📌 **Outcome**: You can now build secure, production-ready networking solutions in Kubernetes with controlled traffic flow.

---

👉 Do you want me to move on to **Module 4 – Storage & Data Management** (covering Persistent Volumes, StorageClasses, StatefulSets, and backup strategies) in the same professional format?

—------------------------&--------------------------
Awesome 🚀 Let’s move on to **Module 4 – Storage & Data Management in Kubernetes**.

---

# 💾 **Module 4 – Storage & Data Management in Kubernetes**

---

## 🚀 1. Introduction

Storage is a **critical piece in Kubernetes** because:

* Pods are ephemeral (if a pod dies, its data is lost).
* Stateful applications (DBs, MQs, file servers) need **persistent storage**.
* Enterprises need dynamic provisioning, snapshots, and backups.

This module covers:

* Kubernetes Volumes basics.
* Persistent Volumes (PV) & Persistent Volume Claims (PVC).
* Storage Classes (SC) & dynamic provisioning.
* Ephemeral vs Persistent storage.
* CSI (Container Storage Interface).
* StatefulSets for managing stateful workloads.
* Backup & Disaster Recovery strategies.

---

## 🗂️ 2. Volumes in Kubernetes

### 📖 Concepts

* **emptyDir** → Temporary storage shared by containers in a pod.
* **hostPath** → Uses the node’s filesystem (not recommended for prod).
* **PersistentVolume (PV)** → Actual storage (EBS, NFS, Ceph, etc).
* **PersistentVolumeClaim (PVC)** → Request for PV by pods.
* **StorageClass** → Defines how PVs are provisioned dynamically.

### 🚀 Best Practices

* Avoid `hostPath` in production.
* Use **StorageClasses with dynamic provisioning**.
* Always enable **encryption at rest** (AWS EBS, Azure Disk, etc).

---

## 🧪 3. Hands-on Labs

### 🔹 Lab 1: Using emptyDir

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: busybox
spec:
  containers:
  - name: busybox
    image: busybox
    command: ["sleep", "3600"]
    volumeMounts:
    - mountPath: /data
      name: temp-storage
  volumes:
  - name: temp-storage
    emptyDir: {}
```

---

### 🔹 Lab 2: PersistentVolume & PVC

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-demo
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-demo
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 500Mi
```

---

### 🔹 Lab 3: StorageClass & Dynamic Provisioning (AWS EBS example)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gp2-storage
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
  fsType: ext4
reclaimPolicy: Delete
```

Create PVC with SC:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-dynamic
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: gp2-storage
```

---

### 🔹 Lab 4: StatefulSet with PVCs

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: "mysql"
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: root123
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 5Gi
```

---

## 🔌 4. Container Storage Interface (CSI)

### 📖 Concepts

* CSI is a standard for integrating storage providers.
* Replaces in-tree storage drivers.
* Supports: EBS, GCE Persistent Disk, Ceph, NFS, Portworx, OpenEBS.

### 🚀 Best Practices

* Always use **CSI drivers** (not legacy provisioners).
* Use **snapshotting & cloning** with CSI (for backups & testing).

---

## 📦 5. Backup & Disaster Recovery

### 📖 Concepts

* Stateless apps → redeploy anytime.
* Stateful apps → need **backup strategy**.
* Tools:

  * **Velero** → backup/restore Kubernetes objects & volumes.
  * **Stash** → backup for databases.
  * **Cloud-native snapshots** (AWS EBS, Azure Disk).

### 🚀 Best Practices

* Automate daily backups of DBs.
* Store backups in **separate cloud storage** (S3/GCS).
* Regularly test **restore procedures**.

---

## 🎯 6. Interview & Discussion Questions

1. What’s the difference between **emptyDir** and **PersistentVolume**?
2. How does **dynamic provisioning** work with StorageClasses?
3. Can you explain **StatefulSet vs Deployment** in terms of storage?
4. Why should you avoid using **hostPath** in production?
5. How would you implement **backup & restore** for a Kubernetes MySQL DB?

---

## ✅ Summary of Module 4

By completing this module, you now understand:

* Volumes, PersistentVolumes, and PVCs.
* StorageClasses & dynamic provisioning with CSI.
* Running Stateful workloads with StatefulSets.
* Backup & disaster recovery strategies.

📌 **Outcome**: You can now confidently handle **stateful applications in Kubernetes**, ensuring persistence, scalability, and resilience.

